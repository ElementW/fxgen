#ifndef _WIN32
#include <string.h> // memcpy
#endif

#include "VecMath.h"




//-----------------------------------------------------------------------------
// Default Constructor
//-----------------------------------------------------------------------------
Vec3::Vec3()
{
	x = 0.0f;
	y = 0.0f;
	z = 0.0f;
}

//-----------------------------------------------------------------------------
// Initialization Constructor
//-----------------------------------------------------------------------------
Vec3::Vec3( float X, float Y, float Z )
{
	x = X;
	y = Y;
	z = Z;
}

//-----------------------------------------------------------------------------
// Deep copy constructor
//-----------------------------------------------------------------------------
Vec3::Vec3( const Vec3 &rhs )
{
	x = rhs.x;
	y = rhs.y;
	z = rhs.z;
}

//-----------------------------------------------------------------------------
// pointer copy constructor
//-----------------------------------------------------------------------------
Vec3::Vec3( Vec3 *ptr )
{
	x = ptr->x;
	y = ptr->y;
	z = ptr->z;
}

//-----------------------------------------------------------------------------
// destructor
//-----------------------------------------------------------------------------
Vec3::~Vec3()
{
}

//-----------------------------------------------------------------------------
// equality test operator
//-----------------------------------------------------------------------------
bool Vec3::operator==( const Vec3 &rhs )
{
	return ( x == rhs.x &&
		     y == rhs.y &&
		     z == rhs.z );
}

//-----------------------------------------------------------------------------
// inequality test operator
//-----------------------------------------------------------------------------
bool Vec3::operator!=( const Vec3 &rhs )
{
	return ( x != rhs.x ||
			 y != rhs.y ||
			 z != rhs.z );
}

//-----------------------------------------------------------------------------
// plus-equals operator on a reference to a Vec3
//-----------------------------------------------------------------------------
void Vec3::operator+=( const Vec3 &rhs )
{
	x += rhs.x;
	y += rhs.y;
	z += rhs.z;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// plus-equals operator on a reference to a D3DXVECTOR3
//-----------------------------------------------------------------------------
void Vec3::operator+=( const D3DXVECTOR3 &rhs )
{
	x += rhs.x;
	y += rhs.y;
	z += rhs.z;
}
#endif

//-----------------------------------------------------------------------------
// minus-equals operator on a reference to a Vec3
//-----------------------------------------------------------------------------
void Vec3::operator-=( const Vec3 &rhs )
{
	x -= rhs.x;
	y -= rhs.y;
	z -= rhs.z;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// minus-equals operator on a reference to a D3DXVECTOR3
//-----------------------------------------------------------------------------
void Vec3::operator-=( const D3DXVECTOR3 &rhs )
{
	x -= rhs.x;
	y -= rhs.y;
	z -= rhs.z;
}
#endif

//-----------------------------------------------------------------------------
// plus-equals operator
//-----------------------------------------------------------------------------
void Vec3::operator+=( const float P )
{
	x += P;
	y += P;
	z += P;
}

//-----------------------------------------------------------------------------
// minus-equals operator
//-----------------------------------------------------------------------------
void Vec3::operator-=( const float P )
{
	x -= P;
	y -= P;
	z -= P;
}

//-----------------------------------------------------------------------------
// divide-equals operator
//-----------------------------------------------------------------------------
void Vec3::operator/=( const float P )
{
	float p = 1/P;
	x *= p;
	y *= p;
	z *= p;
}

//-----------------------------------------------------------------------------
// times-equals operator
//-----------------------------------------------------------------------------
void Vec3::operator*=( const float P )
{
	x *= P;
	y *= P;
	z *= P;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// dot product with a reference to a D3DXVECTOR3
//-----------------------------------------------------------------------------
inline float Vec3::Dot( const D3DXVECTOR3 &rhs )
{
	return x*rhs.x +
		   y*rhs.y +
		   z*rhs.z;
}
#endif

//-----------------------------------------------------------------------------
// Cross Product using references to Vec3 objects
//-----------------------------------------------------------------------------
Vec3 Vec3::CrossProduct( Vec3 &out, const Vec3 &rhs )
{
	out.x = y*rhs.z - z*rhs.y;
	out.y = - x*rhs.z + z*rhs.x;
	out.z = x*rhs.y - y*rhs.x;

	return out;
}

//-----------------------------------------------------------------------------
// Cross Product between references to Vec3 objects
// the result is stored in out
//-----------------------------------------------------------------------------
Vec3 Vec3::Cross( const Vec3 &v1, const Vec3 &v2 )
{
	Vec3 vout;
	vout.x = v1.y*v2.z - v1.z*v2.y;
	vout.y = -v1.x*v2.z + v1.z*v2.x;
	vout.z = v1.x*v2.y - v1.y*v2.x;
	return vout;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Cross Product using references to D3DXVECTOR3 objects
//-----------------------------------------------------------------------------
D3DXVECTOR3 Vec3::CrossProduct( D3DXVECTOR3 &out, const D3DXVECTOR3 &rhs )
{
	out.x = y*rhs.z - z*rhs.y;
	out.y = - x*rhs.z + z*rhs.x;
	out.z = x*rhs.y - y*rhs.x;

	return out;
}
#endif

//-----------------------------------------------------------------------------
// Magnitude of this vector
//-----------------------------------------------------------------------------
inline float Vec3::Magnitude()
{
	return sqrtf( x*x+y*y+z*z );
}

//-----------------------------------------------------------------------------
// Normalizes this Vector
//-----------------------------------------------------------------------------
void Vec3::Normalize()
{
	float recip = 1/Magnitude();

	x *= recip;
	y *= recip;
	z *= recip;
}

//-----------------------------------------------------------------------------
// Addition of v1 and v2 stored in vout using references to Vec3 objects
//-----------------------------------------------------------------------------
void Add( Vec3 &vout, const Vec3 &v1, const Vec3 &v2 )
{
	vout.x = v1.x + v2.x;
	vout.y = v1.y + v2.y;
	vout.z = v1.z + v2.z;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Addition of v1 and v2 stored in vout using references to D3DXVECTOR3 objects
//-----------------------------------------------------------------------------
void Add( Vec3 &vout, const D3DXVECTOR3 &v1, const D3DXVECTOR3 &v2 )
{
	vout.x = v1.x + v2.x;
	vout.y = v1.y + v2.y;
	vout.z = v1.z + v2.z;
}
#endif

//-----------------------------------------------------------------------------
// Magnitude of a Vec3 reference
//-----------------------------------------------------------------------------
float Magnitude(const Vec3& v)
{
	float mag_squared = v.x*v.x +
					    v.y*v.y +
						v.z*v.z;

	return sqrtf( mag_squared );
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Magnitude of a D3DXVECTOR3 reference
//-----------------------------------------------------------------------------
float Magnitude(const D3DXVECTOR3& v)
{
/*	float mag_squared = v.x*v.x +
					    v.y*v.y +
						v.z*v.z;
*/
	return sqrtf( v.x*v.x +
				  v.y*v.y +
				  v.z*v.z );
}
#endif

//-----------------------------------------------------------------------------
// Dot Product between references to two Vec3 objects
//-----------------------------------------------------------------------------
float Dot( const Vec3 &v1, const Vec3 &v2 )
{
	return v1.x * v2.x +
		   v1.y * v2.y +
		   v1.z * v2.z;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Dot Product between references to a Vec3 object and a D3DXVECTOR3 object
//-----------------------------------------------------------------------------
float Dot( const Vec3 &v1, const D3DXVECTOR3 &v2 )
{
	return v1.x * v2.x +
		   v1.y * v2.y +
		   v1.z * v2.z;
}

//-----------------------------------------------------------------------------
// Dot Product between references to a Vec3 object and a D3DXVECTOR3 object
//-----------------------------------------------------------------------------
float Dot( const D3DXVECTOR3 &v1, const Vec3 &v2 )
{
	return v1.x * v2.x +
		   v1.y * v2.y +
		   v1.z * v2.z;
}
#endif

//-----------------------------------------------------------------------------
// Cross Product between references to Vec3 objects
// the result is stored in out
//-----------------------------------------------------------------------------
void Cross( Vec3 &vout, const Vec3 &v1, const Vec3 &v2 )
{
	vout.x = v1.y*v2.z - v1.z*v2.y;
	vout.y = -v1.x*v2.z + v1.z*v2.x;
	vout.z = v1.x*v2.y - v1.y*v2.x;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Cross Product between references to a Vec3 and a D3DXVECTOR3
// the result is stored in out
//-----------------------------------------------------------------------------
void Cross( Vec3 &out, const Vec3 &v1, const D3DXVECTOR3 &v2 )
{
	out.x = v1.y*v2.z - v1.z*v2.y;
	out.y = -v1.x*v2.z + v1.z*v2.x;
	out.z = v1.x*v2.y - v1.y*v2.x;
}

//-----------------------------------------------------------------------------
// Cross Product between references to a D3DXVECTOR3 and a Vec3
// the result is stored in out
//-----------------------------------------------------------------------------
void Cross( Vec3 &out, const D3DXVECTOR3 &v1, const Vec3 &v2 )
{
	out.x = v1.y*v2.z - v1.z*v2.y;
	out.y = -v1.x*v2.z + v1.z*v2.x;
	out.z = v1.x*v2.y - v1.y*v2.x;
}

//-----------------------------------------------------------------------------
// Cross Product between references to two D3DXVECTOR3 objects
// the result is stored in out, a Vec3
//-----------------------------------------------------------------------------
void Cross( Vec3 &out, const D3DXVECTOR3 &v1, const D3DXVECTOR3 &v2 )
{
	out.x = v1.y*v2.z - v1.z*v2.y;
	out.y = -v1.x*v2.z + v1.z*v2.x;
	out.z = v1.x*v2.y - v1.y*v2.x;
}
#endif

//-----------------------------------------------------------------------------
// Normalizes vin into vout
//-----------------------------------------------------------------------------
void NormalizeInto( Vec3 &vout, const Vec3 &vin )
{
	float mag = Magnitude(vin);

	float recip = 1/mag;

	vout.x = vin.x * recip;
	vout.y = vin.y * recip;
	vout.z = vin.z * recip;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Normalizes vin into vout
//-----------------------------------------------------------------------------
void NormalizeInto( Vec3 &vout, const D3DXVECTOR3 &vin )
{
	float mag = Magnitude( vin );

	float recip = 1/mag;

	vout.x = vin.x * recip;
	vout.y = vin.y * recip;
	vout.z = vin.z * recip;
}
#endif

//-----------------------------------------------------------------------------
// Computes the distance between two vectors
//-----------------------------------------------------------------------------
float Distance( Vec3 &v1, Vec3 &v2 )
{
	return sqrtf( POW( (v1.x - v2.x) ) +
				  POW( (v1.y - v2.y) ) +
				  POW( (v1.z - v2.z) ));
}

//-----------------------------------------------------------------------------
// Default Constructor
//-----------------------------------------------------------------------------
Mat44::Mat44()
{
	_11 = 1.0f;  _12 = 0.0f;  _13 = 0.0f;  _14 = 0.0f;
	_21 = 0.0f;  _22 = 1.0f;  _23 = 0.0f;  _24 = 0.0f;
	_31 = 0.0f;  _32 = 0.0f;  _33 = 1.0f;  _34 = 0.0f;
	_41 = 0.0f;  _42 = 0.0f;  _43 = 0.0f;  _44 = 1.0f;
}

//-----------------------------------------------------------------------------
// Initialization constructor
//-----------------------------------------------------------------------------
Mat44::Mat44( float m11, float m12, float m13, float m14,
		        	  float m21, float m22, float m23, float m24,
					  float m31, float m32, float m33, float m34,
					  float m41, float m42, float m43, float m44 )
{
	_11 = m11;  _12 = m12;  _13 = m13;  _14 = m14;
	_21 = m21;  _22 = m22;  _23 = m23;  _24 = m24;
	_31 = m31;  _32 = m32;  _33 = m33;  _34 = m34;
	_41 = m41;  _42 = m42;  _43 = m43;  _44 = m44;
}

//-----------------------------------------------------------------------------
// Deep copy constructor
//-----------------------------------------------------------------------------
Mat44::Mat44( Mat44 &rhs )
{
	_11 = rhs._11;  _12 = rhs._12;  _13 = rhs._13;  _14 = rhs._14;
	_21 = rhs._21;  _22 = rhs._22;  _23 = rhs._23;  _24 = rhs._24;
	_31 = rhs._31;  _32 = rhs._32;  _33 = rhs._33;  _34 = rhs._34;
	_41 = rhs._41;  _42 = rhs._42;  _43 = rhs._43;  _44 = rhs._44;
}

//-----------------------------------------------------------------------------
// pointer constructor
//-----------------------------------------------------------------------------
Mat44::Mat44( Mat44 *ptr )
{
	_11 = ptr->_11;  _12 = ptr->_12;  _13 = ptr->_13;  _14 = ptr->_14;
	_21 = ptr->_21;  _22 = ptr->_22;  _23 = ptr->_23;  _24 = ptr->_24;
	_31 = ptr->_31;  _32 = ptr->_32;  _33 = ptr->_33;  _34 = ptr->_34;
	_41 = ptr->_41;  _42 = ptr->_42;  _43 = ptr->_43;  _44 = ptr->_44;
}

//-----------------------------------------------------------------------------
// destructor
//-----------------------------------------------------------------------------
Mat44::~Mat44()
{
}

//-----------------------------------------------------------------------------
// plus equals operator on a reference to a Mat44
//-----------------------------------------------------------------------------
void Mat44::operator+=( Mat44 &rhs )
{
	_11 += rhs._11;  _12 += rhs._12;  _13 += rhs._13;  _14 += rhs._14;
	_21 += rhs._21;  _22 += rhs._22;  _23 += rhs._23;  _24 += rhs._24;
	_31 += rhs._31;  _32 += rhs._32;  _33 += rhs._33;  _34 += rhs._34;
	_41 += rhs._41;  _42 += rhs._42;  _43 += rhs._43;  _44 += rhs._44;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// plus equals operator on a reference to a D3DXMATRIXA16
//-----------------------------------------------------------------------------
void Mat44::operator+=( D3DXMATRIXA16 &rhs )
{
	_11 += rhs._11;  _12 += rhs._12;  _13 += rhs._13;  _14 += rhs._14;
	_21 += rhs._21;  _22 += rhs._22;  _23 += rhs._23;  _24 += rhs._24;
	_31 += rhs._31;  _32 += rhs._32;  _33 += rhs._33;  _34 += rhs._34;
	_41 += rhs._41;  _42 += rhs._42;  _43 += rhs._43;  _44 += rhs._44;
}
#endif

//-----------------------------------------------------------------------------
// minus equals operator on a reference to a Mat44
//-----------------------------------------------------------------------------
void Mat44::operator-=( Mat44 &rhs )
{
	_11 -= rhs._11;  _12 -= rhs._12;  _13 -= rhs._13;  _14 -= rhs._14;
	_21 -= rhs._21;  _22 -= rhs._22;  _23 -= rhs._23;  _24 -= rhs._24;
	_31 -= rhs._31;  _32 -= rhs._32;  _33 -= rhs._33;  _34 -= rhs._34;
	_41 -= rhs._41;  _42 -= rhs._42;  _43 -= rhs._43;  _44 -= rhs._44;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// minus equals operator on a reference to a D3DXMATRIXA16
//-----------------------------------------------------------------------------
void Mat44::operator-=( D3DXMATRIXA16 &rhs )
{
	_11 -= rhs._11;  _12 -= rhs._12;  _13 -= rhs._13;  _14 -= rhs._14;
	_21 -= rhs._21;  _22 -= rhs._22;  _23 -= rhs._23;  _24 -= rhs._24;
	_31 -= rhs._31;  _32 -= rhs._32;  _33 -= rhs._33;  _34 -= rhs._34;
	_41 -= rhs._41;  _42 -= rhs._42;  _43 -= rhs._43;  _44 -= rhs._44;
}
#endif

//-----------------------------------------------------------------------------
// Times-Equals operator on a reference to a Mat44
//-----------------------------------------------------------------------------
void Mat44::operator*=( Mat44 &rhs )
{
	_11 = _11 * rhs._11 + _12 * rhs._21 + _13 * rhs._31 + _14 * rhs._41;
	_12 = _11 * rhs._12 + _12 * rhs._22 + _13 * rhs._32 + _14 * rhs._42;
	_13 = _11 * rhs._13 + _12 * rhs._23 + _13 * rhs._33 + _14 * rhs._43;
	_14 = _11 * rhs._14 + _12 * rhs._24 + _13 * rhs._34 + _14 * rhs._44;

	_21 = _21 * rhs._11 + _22 * rhs._21 + _23 * rhs._31 + _24 * rhs._41;
	_22 = _21 * rhs._12 + _22 * rhs._22 + _23 * rhs._32 + _24 * rhs._42;
	_23 = _21 * rhs._13 + _22 * rhs._23 + _23 * rhs._33 + _24 * rhs._43;
	_24 = _21 * rhs._14 + _22 * rhs._24 + _23 * rhs._34 + _24 * rhs._44;

	_31 = _31 * rhs._11 + _32 * rhs._21 + _33 * rhs._31 + _34 * rhs._41;
	_32 = _31 * rhs._12 + _32 * rhs._22 + _33 * rhs._32 + _34 * rhs._42;
	_33 = _31 * rhs._13 + _32 * rhs._23 + _33 * rhs._33 + _34 * rhs._43;
	_34 = _31 * rhs._14 + _32 * rhs._24 + _33 * rhs._34 + _34 * rhs._44;

	_41 = _41 * rhs._11 + _42 * rhs._21 + _43 * rhs._31 + _44 * rhs._41;
	_42 = _41 * rhs._12 + _42 * rhs._22 + _43 * rhs._32 + _44 * rhs._42;
	_43 = _41 * rhs._13 + _42 * rhs._23 + _43 * rhs._33 + _44 * rhs._43;
	_44 = _41 * rhs._14 + _42 * rhs._24 + _43 * rhs._34 + _44 * rhs._44;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Times-Equals operator on a reference to a D3DXMATRIXA16
//-----------------------------------------------------------------------------
void Mat44::operator*=( D3DXMATRIXA16 &rhs )
{
	_11 = _11 * rhs._11 + _12 * rhs._21 + _13 * rhs._31 + _14 * rhs._41;
	_12 = _11 * rhs._12 + _12 * rhs._22 + _13 * rhs._32 + _14 * rhs._42;
	_13 = _11 * rhs._13 + _12 * rhs._23 + _13 * rhs._33 + _14 * rhs._43;
	_14 = _11 * rhs._14 + _12 * rhs._24 + _13 * rhs._34 + _14 * rhs._44;

	_21 = _21 * rhs._11 + _22 * rhs._21 + _23 * rhs._31 + _24 * rhs._41;
	_22 = _21 * rhs._12 + _22 * rhs._22 + _23 * rhs._32 + _24 * rhs._42;
	_23 = _21 * rhs._13 + _22 * rhs._23 + _23 * rhs._33 + _24 * rhs._43;
	_24 = _21 * rhs._14 + _22 * rhs._24 + _23 * rhs._34 + _24 * rhs._44;

	_31 = _31 * rhs._11 + _32 * rhs._21 + _33 * rhs._31 + _34 * rhs._41;
	_32 = _31 * rhs._12 + _32 * rhs._22 + _33 * rhs._32 + _34 * rhs._42;
	_33 = _31 * rhs._13 + _32 * rhs._23 + _33 * rhs._33 + _34 * rhs._43;
	_34 = _31 * rhs._14 + _32 * rhs._24 + _33 * rhs._34 + _34 * rhs._44;

	_41 = _41 * rhs._11 + _42 * rhs._21 + _43 * rhs._31 + _44 * rhs._41;
	_42 = _41 * rhs._12 + _42 * rhs._22 + _43 * rhs._32 + _44 * rhs._42;
	_43 = _41 * rhs._13 + _42 * rhs._23 + _43 * rhs._33 + _44 * rhs._43;
	_44 = _41 * rhs._14 + _42 * rhs._24 + _43 * rhs._34 + _44 * rhs._44;
}
#endif

//-----------------------------------------------------------------------------
// Divide-Equals operator on a float
//-----------------------------------------------------------------------------
void Mat44::operator/=( float F )
{
	float recip = 1/F;
	_11 *= recip;  _12 *= recip;  _13 *= recip;  _14 *= recip;
	_21 *= recip;  _22 *= recip;  _23 *= recip;  _24 *= recip;
	_31 *= recip;  _32 *= recip;  _33 *= recip;  _34 *= recip;
	_41 *= recip;  _42 *= recip;  _43 *= recip;  _44 *= recip;
}

void Mat44::Set( Vec3 R, Vec3 U, Vec3 L, Vec3 P )
{
	_11 = R.x;  _12 = R.y;  _13 = R.z;  _14 = 0.0F;
	_21 = U.x;  _22 = U.y;  _23 = U.z;  _24 = 0.0F;
	_31 = L.x;  _32 = L.y;  _33 = L.z;  _34 = 0.0F;
	_41 = P.x;  _42 = P.y;  _43 = P.z;  _44 = 1.0F;
}

//-----------------------------------------------------------------------------
// Multiplies a vector by a matrix
//-----------------------------------------------------------------------------
void Mat44::MultiplyVector( Vec3 &out, const Vec3 &v )
{
    out.x = v.x*_11 + v.y*_21 + v.z* _31 + _41;
    out.y = v.x*_12 + v.y*_22 + v.z* _32 + _42;
    out.z = v.x*_13 + v.y*_23 + v.z* _33 + _43;

	float w = v.x*_14 + v.y*_24 + v.z* _34 + _44;

#ifdef _MYDEBUG
    if( fabs( w ) < g_EPSILON )
        return;
#endif

	float w_recip = 1/w;

    out.x = out.x * w_recip;
    out.y = out.y * w_recip;
    out.z = out.z * w_recip;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Multiplies a vector by a matrix
//-----------------------------------------------------------------------------
void Mat44::MultiplyVector( Vec3 &out, const D3DXVECTOR3 &v )
{
    out.x = v.x*_11 + v.y*_21 + v.z* _31 + _41;
    out.y = v.x*_12 + v.y*_22 + v.z* _32 + _42;
    out.z = v.x*_13 + v.y*_23 + v.z* _33 + _43;

	float w = v.x*_14 + v.y*_24 + v.z* _34 + _44;

#ifdef _MYDEBUG
    if( fabs( w ) < g_EPSILON )
        return;
#endif

	float w_recip = 1/w;

    out.x = out.x * w_recip;
    out.y = out.y * w_recip;
    out.z = out.z * w_recip;
}
#endif

//-----------------------------------------------------------------------------
// Multiplies a vector by a matrix
//-----------------------------------------------------------------------------
void Mat44::operator=(Mat44 &rhs)
{
	_11 = rhs._11;  _12 = rhs._12;  _13 = rhs._13;  _14 = rhs._14;
	_21 = rhs._21;  _22 = rhs._22;  _23 = rhs._23;  _24 = rhs._24;
	_31 = rhs._31;  _32 = rhs._32;  _33 = rhs._33;  _34 = rhs._34;
	_41 = rhs._41;  _42 = rhs._42;  _43 = rhs._43;  _44 = rhs._44;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// Multiplies a vector by a matrix
//-----------------------------------------------------------------------------
void Mat44::operator=(D3DXMATRIXA16 &rhs)
{
	_11 = rhs._11;  _12 = rhs._12;  _13 = rhs._13;  _14 = rhs._14;
	_21 = rhs._21;  _22 = rhs._22;  _23 = rhs._23;  _24 = rhs._24;
	_31 = rhs._31;  _32 = rhs._32;  _33 = rhs._33;  _34 = rhs._34;
	_41 = rhs._41;  _42 = rhs._42;  _43 = rhs._43;  _44 = rhs._44;
}
#endif

//-----------------------------------------------------------------------------
// Name: VectorMatrixMultiply()
// Desc: Multiplies a vector by a matrix
//-----------------------------------------------------------------------------
void VectorMatrixMultiply( Vec3& vDest, Vec3& vSrc, Mat44& mat)
{
    float x = vSrc.x*mat._11 + vSrc.y*mat._21 + vSrc.z* mat._31 + mat._41;
    float y = vSrc.x*mat._12 + vSrc.y*mat._22 + vSrc.z* mat._32 + mat._42;
    float z = vSrc.x*mat._13 + vSrc.y*mat._23 + vSrc.z* mat._33 + mat._43;
    float w = vSrc.x*mat._14 + vSrc.y*mat._24 + vSrc.z* mat._34 + mat._44;

#ifdef _MYDEBUG
    if( fabs( w ) < g_EPSILON )
        return;
#endif

    vDest.x = x;///w;
    vDest.y = y;///w;
    vDest.z = z;///w;
}

//-----------------------------------------------------------------------------
// Name: Identity()
// Desc: Creates an Identity matrix
//-----------------------------------------------------------------------------
void Identity( Mat44 &m )
{
	m._11 = 1.0f;  m._12 = 0.0f;  m._13 = 0.0f;  m._14 = 0.0f;
	m._21 = 0.0f;  m._22 = 1.0f;  m._23 = 0.0f;  m._24 = 0.0f;
	m._31 = 0.0f;  m._32 = 0.0f;  m._33 = 1.0f;  m._34 = 0.0f;
	m._41 = 0.0f;  m._42 = 0.0f;  m._43 = 0.0f;  m._44 = 1.0f;
}

//-----------------------------------------------------------------------------
// Inverts a a matrix storing result in out - called by reference
// NOTE: This works for matrices with [ 0 0 0 1 ] in the 4th column
//-----------------------------------------------------------------------------
void InvertFast( Mat44 &out, const Mat44 &m1 )
{
#ifdef __MYDEBUG
    if( fabs(m1._44 - 1.0f) > .001f )
        return;
    if( fabs(m1._14) > .001f || fabs(m1._24) > .001f || fabs(m1._34) > .001f )
        return;
#endif

	float fDet =  ( m1._11 * ( m1._22 * m1._33 - m1._23 * m1._32 ) -
                    m1._12 * ( m1._21 * m1._33 - m1._23 * m1._31 ) +
                    m1._13 * ( m1._21 * m1._32 - m1._22 * m1._31 ) );

	float fDetInv = 1.0f / fDet;

    out._11 =  fDetInv * ( m1._22 * m1._33 - m1._23 * m1._32 );
    out._12 = -fDetInv * ( m1._12 * m1._33 - m1._13 * m1._32 );
    out._13 =  fDetInv * ( m1._12 * m1._23 - m1._13 * m1._22 );
    out._14 = 0.0f;

    out._21 = -fDetInv * ( m1._21 * m1._33 - m1._23 * m1._31 );
    out._22 =  fDetInv * ( m1._11 * m1._33 - m1._13 * m1._31 );
    out._23 = -fDetInv * ( m1._11 * m1._23 - m1._13 * m1._21 );
    out._24 = 0.0f;

    out._31 =  fDetInv * ( m1._21 * m1._32 - m1._22 * m1._31 );
    out._32 = -fDetInv * ( m1._11 * m1._32 - m1._12 * m1._31 );
    out._33 =  fDetInv * ( m1._11 * m1._22 - m1._12 * m1._21 );
    out._34 = 0.0f;

    out._41 = -( m1._41 * out._11 + m1._42 * out._21 + m1._43 * out._31 );
    out._42 = -( m1._41 * out._12 + m1._42 * out._22 + m1._43 * out._32 );
    out._43 = -( m1._41 * out._13 + m1._42 * out._23 + m1._43 * out._33 );
    out._44 = 1.0f;
}

//-----------------------------------------------------------------------------
// Full Inversion of Mat44
//-----------------------------------------------------------------------------
void InvertFull( Mat44 &out, Mat44 &m1 )
{
	// find determinant - TODO:- break down into smaller tasks for CPU
	float d1 = 	m1._11 * ( m1(1,1) * (m1(2,2) * m1(3,3) - m1(3,2) * m1(2,3)) -
				           m1(1,2) * (m1(2,1) * m1(3,3) - m1(3,1) * m1(2,3)) +
                           m1(1,3) * (m1(2,1) * m1(3,2) - m1(3,1) * m1(2,2)));

	float d2 = 	m1._12 * ( m1(1,0) * (m1(2,2) * m1(3,3) - m1(3,2) * m1(2,3)) -
                           m1(1,2) * (m1(2,0) * m1(3,3) - m1(3,0) * m1(2,3)) +
                           m1(1,3) * (m1(2,0) * m1(3,2) - m1(3,0) * m1(2,2)));

	float d3 = 	m1._13 * ( m1(1,0) * (m1(2,1) * m1(3,3) - m1(3,1) * m1(2,3)) -
					       m1(1,1) * (m1(2,0) * m1(3,3) - m1(3,0) * m1(2,3)) +
					       m1(1,3) * (m1(2,0) * m1(3,1) - m1(3,0) * m1(2,1)));

	float d4 = 	m1._14 * ( m1(1,0) * (m1(2,1) * m1(3,2) - m1(3,1) * m1(2,2)) -
                           m1(1,1) * (m1(2,0) * m1(3,2) - m1(3,0) * m1(2,2)) +
                           m1(1,2) * (m1(2,0) * m1(3,1) - m1(3,0) * m1(2,1)));

	float det = d1 - d2 + d3 - d4;

	float det_recip = 1 / det;

	// Compute adjoint while mulitplying by the reciprocal
	// of the determinant - TODO:- as above
	out._11 = Minor( m1, 1, 2, 3, 1, 2, 3 ) * det_recip;
    out._12 =-Minor( m1, 0, 2, 3, 1, 2, 3 ) * det_recip;
    out._13 = Minor( m1, 0, 1, 3, 1, 2, 3 ) * det_recip;
    out._14 =-Minor( m1, 0, 1, 2, 1, 2, 3 ) * det_recip;

    out._21 =-Minor( m1, 1, 2, 3, 0, 2, 3 ) * det_recip;
    out._22 = Minor( m1, 0, 2, 3, 0, 2, 3 ) * det_recip;
    out._23 =-Minor( m1, 0, 1, 3, 0, 2, 3 ) * det_recip;
    out._24 = Minor( m1, 0, 1, 2, 0, 2, 3 ) * det_recip;

    out._31 = Minor( m1, 1, 2, 3, 0, 1, 3 ) * det_recip;
    out._32 =-Minor( m1, 0, 2, 3, 0, 1, 3 ) * det_recip;
    out._33 = Minor( m1, 0, 1, 3, 0, 1, 3 ) * det_recip;
    out._34 =-Minor( m1, 0, 1, 2, 0, 1, 3 ) * det_recip;

    out._41 =-Minor( m1, 1, 2, 3, 0, 1, 2 ) * det_recip;
    out._42 = Minor( m1, 0, 2, 3, 0, 1, 2 ) * det_recip;
    out._43 =-Minor( m1, 0, 1, 3, 0, 1, 2 ) * det_recip;
    out._44 = Minor( m1, 0, 1, 2, 0, 1, 2 ) * det_recip;
}

//-----------------------------------------------------------------------------
// Computes the Adjoint Matrix
//-----------------------------------------------------------------------------
void Adjoint( Mat44 &out, Mat44 &m1 )
{
	out._11 = Minor( m1, 1, 2, 3, 1, 2, 3 );
    out._12 =-Minor( m1, 0, 2, 3, 1, 2, 3 );
    out._13 = Minor( m1, 0, 1, 3, 1, 2, 3 );
    out._14 =-Minor( m1, 0, 1, 2, 1, 2, 3 );

    out._21 =-Minor( m1, 1, 2, 3, 0, 2, 3 );
    out._22 = Minor( m1, 0, 2, 3, 0, 2, 3 );
    out._23 =-Minor( m1, 0, 1, 3, 0, 2, 3 );
    out._24 = Minor( m1, 0, 1, 2, 0, 2, 3 );

    out._31 = Minor( m1, 1, 2, 3, 0, 1, 3 );
    out._32 =-Minor( m1, 0, 2, 3, 0, 1, 3 );
    out._33 = Minor( m1, 0, 1, 3, 0, 1, 3 );
    out._34 =-Minor( m1, 0, 1, 2, 0, 1, 3 );

    out._41 =-Minor( m1, 1, 2, 3, 0, 1, 2 );
    out._42 = Minor( m1, 0, 2, 3, 0, 1, 2 );
    out._43 =-Minor( m1, 0, 1, 3, 0, 1, 2 );
    out._44 = Minor( m1, 0, 1, 2, 0, 1, 2 );
}

//-----------------------------------------------------------------------------
// Computes the determinant of a 4*4 matrix
//-----------------------------------------------------------------------------
float Determinant(Mat44 &m)
{
	/*
    return m(0,0) * MINOR( m, 1, 2, 3, 1, 2, 3 ) -
           m(0,1) * MINOR( m, 1, 2, 3, 0, 2, 3 ) +
           m(0,2) * MINOR( m, 1, 2, 3, 0, 1, 3 ) -
           m(0,3) * MINOR( m, 1, 2, 3, 0, 1, 2 );
    */

	float d1 = 	m._11 * ( m(1,1) * (m(2,2) * m(3,3) - m(3,2) * m(2,3)) -
				          m(1,2) * (m(2,1) * m(3,3) - m(3,1) * m(2,3)) +
                          m(1,3) * (m(2,1) * m(3,2) - m(3,1) * m(2,2)));

	float d2 = 	m._12 * ( m(1,0) * (m(2,2) * m(3,3) - m(3,2) * m(2,3)) -
                          m(1,2) * (m(2,0) * m(3,3) - m(3,0) * m(2,3)) +
                          m(1,3) * (m(2,0) * m(3,2) - m(3,0) * m(2,2)));

	float d3 = 	m._13 * ( m(1,0) * (m(2,1) * m(3,3) - m(3,1) * m(2,3)) -
					      m(1,1) * (m(2,0) * m(3,3) - m(3,0) * m(2,3)) +
					      m(1,3) * (m(2,0) * m(3,1) - m(3,0) * m(2,1)));

	float d4 = 	m._14 * ( m(1,0) * (m(2,1) * m(3,2) - m(3,1) * m(2,2)) -
                          m(1,1) * (m(2,0) * m(3,2) - m(3,0) * m(2,2)) +
                          m(1,2) * (m(2,0) * m(3,1) - m(3,0) * m(2,1)));

	return d1 - d2 + d3 - d4;
}

//-----------------------------------------------------------------------------
// Gets a minor from a Mat44
//-----------------------------------------------------------------------------
inline float Minor( Mat44& m, const int r0, const int r1, const int r2,
	                             const int c0, const int c1, const int c2)
{
   return m(r0,c0) * (m(r1,c1) * m(r2,c2) - m(r2,c1) * m(r1,c2)) -
          m(r0,c1) * (m(r1,c0) * m(r2,c2) - m(r2,c0) * m(r1,c2)) +
          m(r0,c2) * (m(r1,c0) * m(r2,c1) - m(r2,c0) * m(r1,c1));
}

//-----------------------------------------------------------------------------
// Transposes m and stores in out - uses references to Mat44 objects
//-----------------------------------------------------------------------------
void Transpose( Mat44 &out, const Mat44 &m )
{
	out._11 = m._11;  out._12 = m._21;  out._13 = m._31;  out._14 = m._41;
	out._21 = m._12;  out._22 = m._22;  out._23 = m._32;  out._24 = m._42;
	out._31 = m._13;  out._32 = m._23;  out._33 = m._33;  out._34 = m._43;
	out._41 = m._14;  out._42 = m._24;  out._43 = m._34;  out._44 = m._44;
}

//-----------------------------------------------------------------------------
// Transpose m1 add to m2 store in out
// out = (m1)^T + m2
//-----------------------------------------------------------------------------
void TransposeAdd( Mat44 &out, const Mat44 &m1, const Mat44 &m2 )
{
	out._11 = m1._11 + m2._11;  out._12 = m1._21 + m2._12;
	out._13 = m1._31 + m2._13;  out._14 = m1._41 + m2._14;

	out._21 = m1._12 + m2._21;  out._22 = m1._22 + m2._22;
	out._23 = m1._32 + m2._23;  out._24 = m1._42 + m2._24;

	out._31 = m1._13 + m2._31;  out._32 = m1._23 + m2._32;
	out._33 = m1._33 + m2._33;  out._34 = m1._43 + m2._34;

	out._41 = m1._14 + m2._41;  out._42 = m1._24 + m2._42;
	out._43 = m1._34 + m2._43;  out._44 = m1._44 + m2._44;
}

//-----------------------------------------------------------------------------
// out = m1*m2     uses Mat44 references as parameters
//-----------------------------------------------------------------------------
void MatMult( Mat44 &out, const Mat44 &m1, const Mat44 &m2 )
{
	out._11 = m1._11 * m2._11 + m1._12 * m2._21 + m1._13 * m2._31 + m1._14 * m2._41;
	out._12 = m1._11 * m2._12 + m1._12 * m2._22 + m1._13 * m2._32 + m1._14 * m2._42;
	out._13 = m1._11 * m2._13 + m1._12 * m2._23 + m1._13 * m2._33 + m1._14 * m2._43;
	out._14 = m1._11 * m2._14 + m1._12 * m2._24 + m1._13 * m2._34 + m1._14 * m2._44;

	out._21 = m1._21 * m2._11 + m1._22 * m2._21 + m1._23 * m2._31 + m1._24 * m2._41;
	out._22 = m1._21 * m2._12 + m1._22 * m2._22 + m1._23 * m2._32 + m1._24 * m2._42;
	out._23 = m1._21 * m2._13 + m1._22 * m2._23 + m1._23 * m2._33 + m1._24 * m2._43;
	out._24 = m1._21 * m2._14 + m1._22 * m2._24 + m1._23 * m2._34 + m1._24 * m2._44;

	out._31 = m1._31 * m2._11 + m1._32 * m2._21 + m1._33 * m2._31 + m1._34 * m2._41;
	out._32 = m1._31 * m2._12 + m1._32 * m2._22 + m1._33 * m2._32 + m1._34 * m2._42;
	out._33 = m1._31 * m2._13 + m1._32 * m2._23 + m1._33 * m2._33 + m1._34 * m2._43;
	out._34 = m1._31 * m2._14 + m1._32 * m2._24 + m1._33 * m2._34 + m1._34 * m2._44;

	out._41 = m1._41 * m2._11 + m1._42 * m2._21 + m1._43 * m2._31 + m1._44 * m2._41;
	out._42 = m1._41 * m2._12 + m1._42 * m2._22 + m1._43 * m2._32 + m1._44 * m2._42;
	out._43 = m1._41 * m2._13 + m1._42 * m2._23 + m1._43 * m2._33 + m1._44 * m2._43;
	out._44 = m1._41 * m2._14 + m1._42 * m2._24 + m1._43 * m2._34 + m1._44 * m2._44;
}

#ifdef _USED3D
//-----------------------------------------------------------------------------
// out = m1*m2     uses Mat44 and D3DXMATRIXA16 pointers as parameters
//-----------------------------------------------------------------------------
void MatMult( Mat44 &out, const Mat44 &m1, const D3DXMATRIXA16 &m2 )
{
	out._11 = m1._11 * m2._11 + m1._12 * m2._21 + m1._13 * m2._31 + m1._14 * m2._41;
	out._12 = m1._11 * m2._12 + m1._12 * m2._22 + m1._13 * m2._32 + m1._14 * m2._42;
	out._13 = m1._11 * m2._13 + m1._12 * m2._23 + m1._13 * m2._33 + m1._14 * m2._43;
	out._14 = m1._11 * m2._14 + m1._12 * m2._24 + m1._13 * m2._34 + m1._14 * m2._44;

	out._21 = m1._21 * m2._11 + m1._22 * m2._21 + m1._23 * m2._31 + m1._24 * m2._41;
	out._22 = m1._21 * m2._12 + m1._22 * m2._22 + m1._23 * m2._32 + m1._24 * m2._42;
	out._23 = m1._21 * m2._13 + m1._22 * m2._23 + m1._23 * m2._33 + m1._24 * m2._43;
	out._24 = m1._21 * m2._14 + m1._22 * m2._24 + m1._23 * m2._34 + m1._24 * m2._44;

	out._31 = m1._31 * m2._11 + m1._32 * m2._21 + m1._33 * m2._31 + m1._34 * m2._41;
	out._32 = m1._31 * m2._12 + m1._32 * m2._22 + m1._33 * m2._32 + m1._34 * m2._42;
	out._33 = m1._31 * m2._13 + m1._32 * m2._23 + m1._33 * m2._33 + m1._34 * m2._43;
	out._34 = m1._31 * m2._14 + m1._32 * m2._24 + m1._33 * m2._34 + m1._34 * m2._44;

	out._41 = m1._41 * m2._11 + m1._42 * m2._21 + m1._43 * m2._31 + m1._44 * m2._41;
	out._42 = m1._41 * m2._12 + m1._42 * m2._22 + m1._43 * m2._32 + m1._44 * m2._42;
	out._43 = m1._41 * m2._13 + m1._42 * m2._23 + m1._43 * m2._33 + m1._44 * m2._43;
	out._44 = m1._41 * m2._14 + m1._42 * m2._24 + m1._43 * m2._34 + m1._44 * m2._44;
}

//-----------------------------------------------------------------------------
// out = m1*m2     uses Mat44 and D3DXMATRIXA16 pointers as parameters
//-----------------------------------------------------------------------------
void MatMult( Mat44 &out, const D3DXMATRIXA16 &m1, const Mat44 &m2 )
{
	out._11 = m1._11 * m2._11 + m1._12 * m2._21 + m1._13 * m2._31 + m1._14 * m2._41;
	out._12 = m1._11 * m2._12 + m1._12 * m2._22 + m1._13 * m2._32 + m1._14 * m2._42;
	out._13 = m1._11 * m2._13 + m1._12 * m2._23 + m1._13 * m2._33 + m1._14 * m2._43;
	out._14 = m1._11 * m2._14 + m1._12 * m2._24 + m1._13 * m2._34 + m1._14 * m2._44;

	out._21 = m1._21 * m2._11 + m1._22 * m2._21 + m1._23 * m2._31 + m1._24 * m2._41;
	out._22 = m1._21 * m2._12 + m1._22 * m2._22 + m1._23 * m2._32 + m1._24 * m2._42;
	out._23 = m1._21 * m2._13 + m1._22 * m2._23 + m1._23 * m2._33 + m1._24 * m2._43;
	out._24 = m1._21 * m2._14 + m1._22 * m2._24 + m1._23 * m2._34 + m1._24 * m2._44;

	out._31 = m1._31 * m2._11 + m1._32 * m2._21 + m1._33 * m2._31 + m1._34 * m2._41;
	out._32 = m1._31 * m2._12 + m1._32 * m2._22 + m1._33 * m2._32 + m1._34 * m2._42;
	out._33 = m1._31 * m2._13 + m1._32 * m2._23 + m1._33 * m2._33 + m1._34 * m2._43;
	out._34 = m1._31 * m2._14 + m1._32 * m2._24 + m1._33 * m2._34 + m1._34 * m2._44;

	out._41 = m1._41 * m2._11 + m1._42 * m2._21 + m1._43 * m2._31 + m1._44 * m2._41;
	out._42 = m1._41 * m2._12 + m1._42 * m2._22 + m1._43 * m2._32 + m1._44 * m2._42;
	out._43 = m1._41 * m2._13 + m1._42 * m2._23 + m1._43 * m2._33 + m1._44 * m2._43;
	out._44 = m1._41 * m2._14 + m1._42 * m2._24 + m1._43 * m2._34 + m1._44 * m2._44;
}

//-----------------------------------------------------------------------------
// out = m1*m2    uses Mat44 and D3DXMATRIXA16 pointers as parameters
//-----------------------------------------------------------------------------
void MatMult( Mat44 &out, const D3DXMATRIXA16 &m1, const D3DXMATRIXA16 &m2 )
{
	out._11 = m1._11 * m2._11 + m1._12 * m2._21 + m1._13 * m2._31 + m1._14 * m2._41;
	out._12 = m1._11 * m2._12 + m1._12 * m2._22 + m1._13 * m2._32 + m1._14 * m2._42;
	out._13 = m1._11 * m2._13 + m1._12 * m2._23 + m1._13 * m2._33 + m1._14 * m2._43;
	out._14 = m1._11 * m2._14 + m1._12 * m2._24 + m1._13 * m2._34 + m1._14 * m2._44;

	out._21 = m1._21 * m2._11 + m1._22 * m2._21 + m1._23 * m2._31 + m1._24 * m2._41;
	out._22 = m1._21 * m2._12 + m1._22 * m2._22 + m1._23 * m2._32 + m1._24 * m2._42;
	out._23 = m1._21 * m2._13 + m1._22 * m2._23 + m1._23 * m2._33 + m1._24 * m2._43;
	out._24 = m1._21 * m2._14 + m1._22 * m2._24 + m1._23 * m2._34 + m1._24 * m2._44;

	out._31 = m1._31 * m2._11 + m1._32 * m2._21 + m1._33 * m2._31 + m1._34 * m2._41;
	out._32 = m1._31 * m2._12 + m1._32 * m2._22 + m1._33 * m2._32 + m1._34 * m2._42;
	out._33 = m1._31 * m2._13 + m1._32 * m2._23 + m1._33 * m2._33 + m1._34 * m2._43;
	out._34 = m1._31 * m2._14 + m1._32 * m2._24 + m1._33 * m2._34 + m1._34 * m2._44;

	out._41 = m1._41 * m2._11 + m1._42 * m2._21 + m1._43 * m2._31 + m1._44 * m2._41;
	out._42 = m1._41 * m2._12 + m1._42 * m2._22 + m1._43 * m2._32 + m1._44 * m2._42;
	out._43 = m1._41 * m2._13 + m1._42 * m2._23 + m1._43 * m2._33 + m1._44 * m2._43;
	out._44 = m1._41 * m2._14 + m1._42 * m2._24 + m1._43 * m2._34 + m1._44 * m2._44;
}
#endif

//-----------------------------------------------------------------------------
// copies in into out
//-----------------------------------------------------------------------------
void MatCpy( Mat44 &out, Mat44 &in )
{
	memcpy( (void*)&out, (void*)&in, sizeof( float ) * 16 );

/*
	out._11 = in._11;  out._12 = in._12;  out._13 = in._13;  out._14 = in._14;
	out._21 = in._21;  out._22 = in._22;  out._23 = in._23;  out._24 = in._24;
	out._31 = in._31;  out._32 = in._32;  out._33 = in._33;  out._34 = in._34;
	out._41 = in._41;  out._42 = in._42;  out._43 = in._43;  out._44 = in._44;
*/
}

//-----------------------------------------------------------------------------
// Return a 3D translation Mat44
//-----------------------------------------------------------------------------
Mat44 TranslateMatrix44(float x, float y, float z)
{
  Mat44 ret;

  Identity(ret);
  ret(3,0) = x;
  ret(3,1) = y;
  ret(3,2) = z;

  return ret;
}

//-----------------------------------------------------------------------------
// Creates a X rotation matrix
//-----------------------------------------------------------------------------
void RotationMatrixX( Mat44 &out, float angle )
{
	float sinA, cosA;

	sinA = (float)sin(angle);
	cosA = (float)cos(angle);

	out(0,0) =  1.0F; out(1,0) =  0.0F; out(2,0) =  0.0F;
	out(0,1) =  0.0F; out(1,1) =  cosA; out(2,1) = -sinA;
	out(0,2) =  0.0F; out(1,2) =  sinA; out(2,2) =  cosA;

	out(0,3) = 0.0F;
	out(1,3) = 0.0F;
	out(2,3) = 0.0F;
	out(3,0) = 0.0F;
	out(3,1) = 0.0F;
	out(3,2) = 0.0F;
	out(3,3) = 1.0F;
}

//-----------------------------------------------------------------------------
// Creates a Y rotation matrix
//-----------------------------------------------------------------------------
void RotationMatrixY( Mat44 &out, float angle )
{
	float sinA, cosA;

	sinA = (float)sin(angle);
	cosA = (float)cos(angle);

    out(0,0) =  cosA; out(1,0) =  0.0F; out(2,0) =  sinA;
    out(0,1) =  0.0F; out(1,1) =  1.0F; out(2,1) =  0.0F;
    out(0,2) = -sinA; out(1,2) =  0.0F; out(2,2) =  cosA;

	out(0,3) = 0.0F;
	out(1,3) = 0.0F;
	out(2,3) = 0.0F;
	out(3,0) = 0.0F;
	out(3,1) = 0.0F;
	out(3,2) = 0.0F;
	out(3,3) = 1.0F;
}

//-----------------------------------------------------------------------------
// Creates a Z rotation matrix
//-----------------------------------------------------------------------------
void RotationMatrixZ( Mat44 &out, float angle )
{
	float sinA, cosA;

	sinA = (float)sin(angle);
	cosA = (float)cos(angle);

    out(0,0) =  cosA; out(1,0) = -sinA; out(2,0) =  0.0F;
    out(0,1) =  sinA; out(1,1) =  cosA; out(2,1) =  0.0F;
    out(0,2) =  0.0F; out(1,2) =  0.0F; out(2,2) =  1.0F;

	out(0,3) = 0.0F;
	out(1,3) = 0.0F;
	out(2,3) = 0.0F;
	out(3,0) = 0.0F;
	out(3,1) = 0.0F;
	out(3,2) = 0.0F;
	out(3,3) = 1.0F;
}

//-----------------------------------------------------------------------------
// Creates an axis rotation matrix
//-----------------------------------------------------------------------------
void RotationMatrixAxis( Mat44 &out, Vec3& axis, float angle )
{
	float sinA, cosA;
	float invCosA;
	float x, y, z;
	float xSq, ySq, zSq;

	Vec3 nrm = axis;
	nrm.Normalize();

	sinA = (float)sin(angle);
	cosA = (float)cos(angle);
	invCosA = 1.0F - cosA;

	x = nrm.x;
	y = nrm.y;
	z = nrm.z;

	xSq = x * x;
	ySq = y * y;
	zSq = z * z;

	out._11 = (invCosA * xSq) + (cosA);
	out._21 = (invCosA * x * y) - (sinA * z );
	out._31 = (invCosA * x * z) + (sinA * y );
	out._41 = 0.0F;

	out._12 = (invCosA * x * y) + (sinA * z);
	out._22 = (invCosA * ySq) + (cosA);
	out._32 = (invCosA * y * z) - (sinA * x);
	out._42 = 0.0F;

	out._13 = (invCosA * x * z) - (sinA * y);
	out._23 = (invCosA * y * z) + (sinA * x);
	out._33 = (invCosA * zSq) + (cosA);
	out._43 = 0.0F;

	out._14 = 0.0F;
	out._24 = 0.0F;
	out._34 = 0.0F;
	out._44 = 1.0F;
}

//-----------------------------------------------------------------------------
// Name: LookAtMatrix44
// Desc: Creates a Look-At Matrix from 3 vectors
//-----------------------------------------------------------------------------
Mat44 LookAtMatrix44( Vec3 &camPos,  Vec3 &camUp,
                         Vec3 &target )
{
	Mat44 ret;

	Vec3 F = target - camPos;
	F.Normalize();

	Vec3 upNorm = camUp;
	upNorm.Normalize();

	Vec3 s;
	Cross( s, F, upNorm );
	Vec3 u;
	Cross( u, s, F );

	ret._11 = s.x;  ret._21 = s.y;  ret._31 = s.z;  ret._41 = 0.0F;
	ret._12 = u.x;  ret._22 = u.y;  ret._32 = u.z;  ret._42 = 0.0F;
	ret._13 =-F.x;  ret._23 =-F.y;  ret._33 =-F.z;  ret._43 = 0.0F;
	ret._14 = 0.0F; ret._24 = 0.0F; ret._34 = 0.0F; ret._44 = 1.0F;

	return ret;
}

//-----------------------------------------------------------------------------
// Return a perspective Mat44 given the field-of-view in the Y
//   direction in radians, the aspect ratio of Y/X, and near and
//   far plane distances.
//-----------------------------------------------------------------------------
Mat44 PerspectiveMatrix44( float fovY, float aspect, float n, float f )
{
	Mat44 ret;
	float angle;
	float cot;

	angle = fovY / 2.0F;
	//angle *= 0.01745329252f;// DegToRad( angle );

	cot = (float) (cosf(angle) / sinf(angle));

	ret(0,0) = cot / aspect;
	ret(0,1) = 0.0F;
	ret(0,2) = 0.0F;
	ret(0,3) = 0.0F;

	ret(1,0) = 0.0F;
	ret(1,1) = cot;
	ret(1,2) = 0.0F;
	ret(1,3) = 0.0F;

	ret(2,0) = 0.0F;
	ret(2,1) = 0.0F;
	ret(2,2) = f / (f - n);
	ret(2,3) = 1.0F;


	ret(3,0) = 0.0F;
	ret(3,1) = 0.0F;
	ret(3,2) = -f * n / (f - n);
	ret(3,3) = 0.0F;

	return ret;
}

//-----------------------------------------------------------------------------
// Return a frustum Mat44 given the left, right, bottom, top,
//   near, and far values for the frustum boundaries.
//-----------------------------------------------------------------------------
Mat44
FrustumMatrix44
(
	float l, float r,
    float b, float t,
	float n, float f
)
{
	Mat44 ret;
	float width = r-l;
	float height = t-b;
	float depth = f-n;

	ret(0,0) = (2*n) / width;
	ret(0,1) = 0.0F;
	ret(0,2) = 0.0F;
	ret(0,3) = 0.0F;

	ret(1,0) = 0.0F;
	ret(1,1) = (2*n) / height;
	ret(1,2) = 0.0F;
	ret(1,3) = 0.0F;

	ret(2,0) = (r + l) / width;
	ret(2,1) = (t + b) / height;
	ret(2,2) = -(f + n) / depth;
	ret(2,3) = -1.0F;

	ret(3,0) = 0.0F;
	ret(3,1) = 0.0F;
	ret(3,2) = -(2*f*n) / depth;
	ret(3,3) = 0.0F;

	return ret;
}

//-----------------------------------------------------------------------------
// Return an orthographic Mat44 given the left, right, bottom, top,
//   near, and far values for the frustum boundaries.
//-----------------------------------------------------------------------------
Mat44 OrthoMatrix44
(
	float l, float r,
    float b, float t,
	float n, float f
)
{
	Mat44 ret;
	float width = r-l;
	float height = t-b;
	float depth = f-n;

	ret(0,0) = 2.0F / width;
	ret(0,1) = 0.0F;
	ret(0,2) = 0.0F;
	ret(0,3) = 0.0F;

	ret(1,0) = 0.0F;
	ret(1,1) = 2.0F / height;
	ret(1,2) = 0.0F;
	ret(1,3) = 0.0F;

	ret(2,0) = 0.0F;
	ret(2,1) = 0.0F;
	ret(2,2) = -(2.0F) / depth;
	ret(2,3) = 0.0F;

	ret(3,0) = -(r + l) / width;
	ret(1,3) = -(t + b) / height;
	ret(3,2) = -(f + n) / depth;
	ret(3,3) = 1.0F;

	return ret;
}

//-----------------------------------------------------------------------------
// Return an orientation matrix using 3 basis normalized vectors
//-----------------------------------------------------------------------------
Mat44
OrthoNormalMatrix44
(
	const Vec3 &xdir,
    const Vec3 &ydir,
	const Vec3 &zdir
)
{
	Mat44 ret;

	ret._11 = xdir.x;  ret._12 = xdir.y;  ret._13 = xdir.x;  ret._14 = 0.0F;
	ret._21 = ydir.x;  ret._22 = ydir.y;  ret._23 = ydir.x;  ret._24 = 0.0F;
	ret._31 = zdir.x;  ret._32 = zdir.y;  ret._33 = zdir.x;  ret._34 = 0.0F;
	ret._41 = 0.0F;    ret._42 = 0.0F;    ret._43 = 0.0F;    ret._44 = 1.0F;

	return ret;
}


//-----------------------------------------------------------------------------
// Name: ScaleMatrix44()
// Desc: Creates a scale matrix.
//-----------------------------------------------------------------------------
void ScaleMatrix44( Mat44& m, float sx, float sy, float sz )
{
	m._11 = sx;    m._12 = 0.0f;  m._13 = 0.0f;  m._14 = 0.0f;
	m._21 = 0.0f;  m._22 = sy;    m._23 = 0.0f;  m._24 = 0.0f;
	m._31 = 0.0f;  m._32 = 0.0f;  m._33 = sz;    m._34 = 0.0f;
	m._41 = 0.0f;  m._42 = 0.0f;  m._43 = 0.0f;  m._44 = 1.0f;
}


//-----------------------------------------------------------------------------
// Name: QuaternionFromRotation()
// Desc: Converts a normalized axis and angle to a unit quaternion.
//-----------------------------------------------------------------------------
VOID QuaternionFromRotation( float& x, float& y, float& z, float& w,
                                     Vec3& v, float fTheta )
{
    x = (float)sinf(fTheta/2) * v.x;
    y = (float)sinf(fTheta/2) * v.y;
    z = (float)sinf(fTheta/2) * v.z;
    w = (float)cosf(fTheta/2);
}

//-----------------------------------------------------------------------------
// Name: RotationFromQuaternion()
// Desc: Converts a normalized axis and angle to a unit quaternion.
//-----------------------------------------------------------------------------
VOID RotationFromQuaternion( Vec3& v, float& fTheta,
                                     float x, float y, float z, float w )

{
    fTheta = (float)( acos(w) * 2 );
    v.x    = (float)( x / sinf(fTheta/2) );
    v.y    = (float)( y / sinf(fTheta/2) );
    v.z    = (float)( z / sinf(fTheta/2) );
}

//-----------------------------------------------------------------------------
// Name: QuaternionFromAngles()
// Desc: Converts euler angles to a unit quaternion.
//-----------------------------------------------------------------------------
VOID QuaternionFromAngles( float& x, float& y, float& z, float& w,
                                   float fYaw, float fPitch, float fRoll )

{
    float fSinYaw   = (float)sinf(fYaw/2);
    float fSinPitch = (float)sinf(fPitch/2);
    float fSinRoll  = (float)sinf(fRoll/2);
    float fCosYaw   = (float)cosf(fYaw/2);
    float fCosPitch = (float)cosf(fPitch/2);
    float fCosRoll  = (float)cosf(fRoll/2);

    x = fSinRoll * fCosPitch * fCosYaw - fCosRoll * fSinPitch * fSinYaw;
    y = fCosRoll * fSinPitch * fCosYaw + fSinRoll * fCosPitch * fSinYaw;
    z = fCosRoll * fCosPitch * fSinYaw - fSinRoll * fSinPitch * fCosYaw;
    w = fCosRoll * fCosPitch * fCosYaw + fSinRoll * fSinPitch * fSinYaw;
}

//-----------------------------------------------------------------------------
// Name: MatrixFromQuaternion()
// Desc: Converts a unit quaternion into a rotation matrix.
//-----------------------------------------------------------------------------
VOID MatrixFromQuaternion( Mat44& mat, float x, float y, float z,
                                   float w )
{
    float xx = x*x,   xy = x*y,   xz = x*z,   xw = x*w;
    float yy = y*y,   yz = y*z,   yw = y*w;
    float zz = z*z,   zw = z*w;
    float ww = w*w;

    mat._11 = xx-yy-zz+ww;
    mat._12 = 2.0f*(xy-zw);
    mat._13 = 2.0f*(xz+yw);

    mat._21 = 2.0f*(xy+zw);
    mat._22 = -xx+yy-zz+ww;
    mat._23 = 2.0f*(yz-xw);

    mat._31 = 2.0f*(xz-yw);
    mat._32 = 2.0f*(yz+xw);
    mat._33 = -xx-yy+zz+ww;

    mat._14 = mat._41 = 0.0f;
    mat._24 = mat._42 = 0.0f;
    mat._34 = mat._43 = 0.0f;
    mat._44 = xx+yy+zz+ww;
}

//-----------------------------------------------------------------------------
// Name: QuaternionFromMatrix()
// Desc: Converts a rotation matrix into a unit quaternion.
//-----------------------------------------------------------------------------
VOID QuaternionFromMatrix( float& x, float& y, float& z, float& w,
                                   Mat44& mat )
{
    float diag1 = + mat._11 - mat._22 - mat._33 + mat._44;
    float diag2 = - mat._11 + mat._22 - mat._33 + mat._44;
    float diag3 = - mat._11 - mat._22 + mat._33 + mat._44;
    float diag4 = + mat._11 + mat._22 + mat._33 + mat._44;

    float max = fmax( diag1, fmax( diag2, fmax( diag3, diag4 ) ) );
    float d   = 1 / ( 2.0f * (float)sqrtf( max ) );

    if( diag1 == max )
    {
        x = max * d;
        y = ( mat._21 + mat._12 ) * d;
        z = ( mat._13 + mat._31 ) * d;
        w = ( mat._32 - mat._23 ) * d;
    }
    else if ( diag2 == max )
    {
        x = ( mat._21 + mat._12 ) * d;
        y = max * d;
        z = ( mat._32 + mat._23 ) * d;
        w = ( mat._13 - mat._31 ) * d;
    }
    else if( diag3 == max )
    {
        x = ( mat._13 + mat._31 ) * d;
        y = ( mat._32 + mat._23 ) * d;
        z = max * d;
        w = ( mat._21 - mat._12 ) * d;
    }
    else if( diag4 == max )
    {
        x = ( mat._32 - mat._23 ) * d;
        y = ( mat._13 - mat._31 ) * d;
        z = ( mat._21 - mat._12 ) * d;
        w = max * d;
    }

    if( w < 0.0f )
    {
        x = -x;   y = -y;   z = -z;   w = -w;
    }
}

//-----------------------------------------------------------------------------
// Name: QuaternionMultiply()
// Desc: Mulitples two quaternions together as in {Q} = {A} * {B}.
//-----------------------------------------------------------------------------
VOID QuaternionMultiply( float& Qx, float& Qy, float& Qz, float& Qw,
                         float Ax, float Ay, float Az, float Aw,
                         float Bx, float By, float Bz, float Bw )
{
    float Dx =   Ax*Bw + Ay*Bz - Az*By + Aw*Bx;
    float Dy = - Ax*Bz + Ay*Bw + Az*Bx + Aw*By;
    float Dz =   Ax*By - Ay*Bx + Az*Bw + Aw*Bz;
    float Dw = - Ax*Bx - Ay*By - Az*Bz + Aw*Bw;

    Qx = Dx; Qy = Dy; Qz = Dz; Qw = Dw;
}

//-----------------------------------------------------------------------------
// Name: QuaternionsSlerp()
// Desc: Compute a quaternion which is the spherical linear interpolation
//       between two other quaternions by dvFraction.
//-----------------------------------------------------------------------------
VOID QuaternionSlerp
(
	float& Qx, float& Qy, float& Qz, float& Qw,
    float  Ax, float  Ay, float  Az, float  Aw,
    float  Bx, float  By, float  Bz, float  Bw,
    float fAlpha
)
{
    float fScale1;
    float fScale2;

    // Compute dot product, aka cos(theta):
    float fCosTheta = Ax*Bx + Ay*By + Az*Bz + Aw*Bw;

    if( fCosTheta < 0.0f )
    {
        // Flip start quaternion
        Ax = -Ax; Ay = -Ay; Az = -Az; Aw = -Aw;
        fCosTheta = -fCosTheta;
    }

    if( fCosTheta + 1.0f > 0.05f )
    {
        // If the quaternions are close, use linear interploation
        if( 1.0f - fCosTheta < 0.05f )
        {
            fScale1 = 1.0f - fAlpha;
            fScale2 = fAlpha;
        }
        else // Otherwise, do spherical interpolation
        {
            float fTheta    = (float)acos( fCosTheta );
            float fSinTheta = (float)sin( fTheta );

            fScale1 = (float)sin( fTheta * (1.0f-fAlpha) ) / fSinTheta;
            fScale2 = (float)sin( fTheta * fAlpha ) / fSinTheta;
        }
    }
    else
    {
        Bx = -Ay;
        By =  Ax;
        Bz = -Aw;
        Bw =  Az;
        fScale1 = (float)sin( PI * (0.5f - fAlpha) );
        fScale2 = (float)sin( PI * fAlpha );
    }

    Qx = fScale1 * Ax + fScale2 * Bx;
    Qy = fScale1 * Ay + fScale2 * By;
    Qz = fScale1 * Az + fScale2 * Bz;
    Qw = fScale1 * Aw + fScale2 * Bw;
}



